
1. 一切（引用类型）都是对象

1. 引用类型的判断用 instanceof
    1. A instanceof B 的判断顺序
        * 沿着 A 的 __proto__ 这条线来找，同时沿着 B 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true, 如果找到终点还未重合，就返回 false.
    1. instanceof 表示的就是一种继承关系，或者说 原型链的结构

1. 值类型的判断用 typeof

1. 对象：若干属性的集合. 
    1. 对象中只有属性，没有方法，方法也是一种属性.
    1. JS 中的对象可以任意扩展属性,没有 class 的约束
    1. 对象的属性可以随时改动

1. 数组就像对象的子集一样，而函数与对象之间，不仅仅是一种包含与被包含的关系，函数与对象之间的关系比较复杂，有一点鸡生蛋蛋生鸡的逻辑.
    1. 对象都是通过函数创建的.
    1. 函数是一种对象
        * 函数  →   prototype属性    →  constructor键
    1. 每一个函数都有一个 prototype 属性
    1. 每一个对象都有一个隐藏的属性 '__proto__', 这个属性引用了创建这个对象的函数的 prototype. 这里的 __proto__ 成为隐式原型
        1. Object.prototype.__proto__  →  null
        1. Object.__proto__ →   Function.prototype
        1. Function.__proto__ → Function.prototype
        1. Function.prototype.__proto__ →   Object.prototype

1. 继承    
    * javascript 中的继承是通过原型链来实现的
    * 访问一个对象的属性时，现在基本属性中查找，如果没有，再沿着 __proto__ 这条链向上找，这就是原型链
    * .hasOwnProperty()
    * 由于所有的对象的原型链都会找到 Object.prototype, 因此所有的对象都会有 Object.prototype 的方法，这就是所谓的 "继承".
    * 每个函数都有的 call、apply 等方法, 继承自 Function.prototype

    * java 中，class 是一个模子, 对象就是被这个模子压出来的月饼，模子是什么样的，月饼就是什么样子的，不能随便动。而在 javascript 中, 没有模子了，月饼被换成了面团，你可以捏成自己想要的样子.

    * 如果你要添加内置方法的原型属性, 最好做一步判断, 如果该属性本来就存在，就没有必要添加了
        * if(typeof Date.prototype.toJSON !== 'function')


## 执行上下文 (Execution Context)

* 在一段 js 代码拿过来运行之前，浏览器就已经做了一些准备工作

* 这个 js 代码段 分为 3 中情况
    1. 全局代码
    1. 函数体
    1. eval 代码

* 执行上下文环境
    * 全局代码上下文环境数据内容
        1. 变量、函数表达式  →   变量声明，默认赋值为 undefined
        1. this  →   赋值
        1. 函数声明  →      赋值 

        这 3 种数据的准备情况 称之为 "执行器上下文"
        
    * 如果代码段是函数体，还要在此基础上附加
        1. 参数 →   赋值
        1. arguments →  赋值
        1. 自由变量的取值作用域　→  赋值
    

* 函数每调用一次，都会产生一个新的执行器上下文环境, 因为不同的调用可能会有不同的参数.

* 自由变量：在 A 作用域中使用的变量 x, 却没有在 A 作用域中声明（即在其他作用域中声明的), 对于 A 作用域来说， x 就是一个自由变量
    * 取 自由变量的值：要到'创建'这个函数的那个作用域中取值, 是'创建'，而不是'调用'
    * 如果跨了一步，没有找到，就接着跨，一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了.
        * 这个一步一步 '跨' 的路线，我们称之为 →  作用域链

        * 文字叙述 取自由变量 的 作用域链 过程
            1. 先在当前作用域中查找，如果有则获取并结束
            1. 如果当前作用域是全局作用域，则证明 该自由变量 没有定义，结束
            1. (不是全局作用域，那就是函数作用域) 将'创建'函数的作用域作为当前作用域

* 函数在定义的时候（不是调用的时候）就已经确定了函数体内部　自由变量　的作用域.

* 在执行代码之前，把将要用到的所有的变量都是先拿出来, 有的直接赋值了，有的先用　undefined　占个位

## this
* 在函数中　this 到底取何值，实在函数真正被调用执行的时候确定的，函数定义的时候确定不了, 因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境.

* 4 种情况
    1. 情况1 构造函数
        * 如果函数作为构造函数用，那么其中的 this 就代表它即将 new 出来的对象.    
    1. 情况2 函数作为对象的一个属性
        * this 指向该对象
    1. 情况3 函数用 call 或者 apply 调用
        * this 的值就是传入的对象的值
    1. 情况4 全局 && 调用普通函数
        * 在全局环境下，this 永远是 window

## 执行上下文栈
* 处于活动状态的上下文环境只有一个

* 执行上下文栈 其实是一个压栈出栈的过程


## 作用域

* 只有两种作用域，全局作用域 和 函数作用域

* 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的.

* 作用域最大的用处就是 隔离变量，不同作用域下同名变量不会有冲突.

* jQuery 源码的嘴歪成是一个自动执行的匿名函数，这些变量通过一个函数被限制在一个独立的作用域中，而不会与全局作用于或者其他函数作用域的同名变量产生冲突。

* 作用域是一个很抽象的概念，类似于一个 "底盘", 其中没有变量。要通过作用与对象的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了的.

* 如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值

    ```
    foo(1);
        arguments[0] →  1
    foo(2);
        arguments[0] →  2
    ```
   
### 闭包
1. 函数作为返回值
1. 函数作为参数传递
```
var max = 10,
    fn = function(x){
        if(x>max){
            console.log(x);
        }
    } 

(function(f){
    var max =100;
    f(15);
}(fn));
自由变量的取值，到创建这个函数的作用域去取值, 所以 max 是 15 而不是 100
```

