# 条件编译(Conditional Compilation)

[link](https://baike.baidu.com/item/%23ifdef/2834634)

这几个宏是为了进行条件编译。一般情况下，源程序中所有的行都参加编译。但是有时希
望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，
这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时
则编译另一组语句。条件编译命令最常见的形式为：

    ```
    #ifdef 标识符
    //程序段1
    #else
    //程序段2
    #endif
    ```

它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，
否则编译程序段2。其中#else部分也可以没有，即：

    ```
    #ifdef 标识符
    //程序段1
    #endif
    ```

这里的“程序段”可以是语句组，也可以是命令行。这种条件编译可以提高C源程序的通用性。
如果一个C源程序在不同计算机系统上运行，而不同的计算机又有一定的差异。例如，我们
有一个数据类型，在Windows平台中，应该使用long类型表示，而在其他平台应该使用
float表示，这样往往需要对源程序作必要的修改，这就降低了程序的通用性。可以用以下
的条件编译：

    ```
    #ifdef WINDOWS
    #define MYTYPE long
    #else
    #define MYTYPE float
    #endif
    ```

如果在Windows上编译程序，则可以在程序的开始加上

    > #define WINDOWS

这样则编译下面的命令行：

    > #define MYTYPE long

如果在这组条件编译命令之前未出现以下命令行：

    > #define WINDOWS

则预编译后程序中的MYTYPE都用float代替。这样，源程序可以不必作任何修改就可以用于
不同类型的计算机系统。当然以上介绍的只是一种简单的情况，可以根据此思路设计出其
它的条件编译。

例如，在调试程序时，常常希望输出一些所需的信息，而在调试完成后不再输出这些信息。
可以在源程序中插入以下的条件编译段：

    ```
    #ifdef DEBUG
    printf("device_open(%p)\n",file);
    #endif
    ```

如果在它的前面有以下命令行：

    > #define DEBUG

则在程序运行时输出file指针的值，以便调试分析。调试完成后只需将这个define命令行
删除即可。有人可能觉得不用条件编译也可达此目的，即在调试时加一批printf语句，调
试后一一将printf语句删除去。的确，这是可以的。但是，当调试时加的printf语句比较
多时，修改的工作量是很大的。用条件编译，则不必一一删改printf语句，只需删除前面
的一条“#define DEBUG”命令即可，这时所有的用DEBUG作标识符的条件编译段都使其中的
printf语句不起作用，即起统一控制的作用，如同一个“开关”一样。

有时也采用下面的形式：

    ```
    #ifndef 标识符
    //程序段1
    #else
    //程序段2
    #endif
    ```

只是第一行与第一种形式不同：将“ifdef”改为“ifndef”。它的作用是：若标识符未被定义
则编译程序段1，否则编译程序段2。这种形式与第一种形式的作用相反。

以上两种形式用法差不多，根据需要任选一种，视方便而定。

还有一种形式，就是#if后面的是一个表达式，而不是一个简单的标识符：

    ```
    #if 表达式
    //程序段1
    #else
    //程序段2
    #endif
    ```

它的作用是：当指定的表达式值为真（非零）时就编译程序段1，否则编译程序段2。可以
事先给定一定条件，使程序在不同的条件下执行不同的功能。

例如：输入一行字母字符，根据需要设置条件编译，使之能将字母全改为大写输出，或全
改为小写字母输出。


    ```
    #define LETTER 1
    int main(int argc,char *argv[])
    {
        char str[20] = "CLanguage";
        char c;
        int i=0;
        while((c = str[i]) != '\0')
        {
            i++;
    #if LETTER
            if(c>='a'&&c<='z')
                c=c-32;
    #else
            if(c>='A'&&c<='Z')
                c=c+32;
    #endif
            printf("%c",c);
        }
        return0;
    }
    ```

运行结果为：

    > CLANGUAGE

先定义LETTER为1，这样在预处理条件编译命令时，由于LETTER为真（非零），则对第一个
if语句进行编译，运行时使小写字母变大写。如果将程序第一行改为：

    > #define LETTER 0

则在预处理时，对第二个if语句进行编译处理，使大写字母变成小写字母（大写字母与相
应的小写字母的ASCII代码差32）。此时运行情况为：

    > clanguage

有人会问：不用条件编译命令而直接用if语句也能达到要求，用条件编译命令有什么好处
呢？的确，此问题完全可以不用条件编译处理，但那样做目标程序长（因为所有语句都编
译），而采用条件编译，可以减少被编译的语句，从而减少目标的长度。当条件编译段比
较多时，目标程序长度可以大大减少。

有人可能还会发现有#if defined (x)这样的使用，x代表的是一个宏，如果定义了x这个宏，
那么，编译器会编译中间的代码。在使用上，其实#ifdef和#if defined(x)的用法一致，
而#ifndef也和#if !defined(x)的用法一致。
