# MASM (the Microsoft Macro Assembler) 

## 汇编语言

汇编语言由以下3类组成

    1. 汇编指令 (**机器码的助记符**, 有对应的机器码)

    2. 伪指令   (没有对应的机器码，由编译器执行,计算机并不执行)
        编译器用的一些命令, 如: assume

    3. 其他符号, 如 + - x / 等(由编译器识别,没有对应的机器码)

CPU 要想运作，就需要指令和数据，指令和数据在存储器中存放，也就是内存

`指令`和`数据`是应用上的概念;在内存或磁盘上，**指令和数据没有任何区别，都是二进制信
息，关键在于如何解释**

一段二进制是指令还是数据由我们说了算

数据如何表示:
    - 1010100200B 二进制
    - 104730O     八进制, 几乎不用
    - 104980D     十进制
    - 89D8H       十六进制

## 注释

行注释
    ; 分号


## 存储单元

存储器被划分为若干个存储单元，每一个存储单元从 0 开始顺序编号, 例如:

    假如一个存储器有128个存储单元，编号 [0,127]

存储单元的单位是 Byte

一个存储单元是 1Byte

8086 有20条数据线, 寻址空间 2^20, 即 1MB
    [00000H, FFFFFH]
    一个十六进制位=4个二进制位, 5 x 4 = 20位


## cpu 对存储器的读写

这里的存储器包括内存、显存等

1. 存储单元的地址               (地址信息)      地址

2. 器件的选择,读或写命令        (控制信息)      控制

3. 读或写的数据                 (数据信息)      数据

地址,控制,数据

在计算机中连接 CPU 和其他芯片的导线，叫做**总线**, bus, 也很形象

    在物理上: 一根根导线的集合

    在逻辑上:
        - 地址总线(AB)
        - 数据总线(DB)
        - 控制总线(CB)

    同一段二进制，在地址总线中就是地址；在数据总线中就是数据；在控制总线中就是控制语句

**要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息(机器码)**

```
+-----+                             +--------+
|     |+----------------------------|        |
|     |+----------------------------|        |
|     |+----------------------------|        |
|     |+-地址总线-------------------|        |
|     |+----------------------------|        |
|     |+----------------------------|        |
|     |+----------------------------|        |
| CPU |                             |  MEM   |
|     |                             |        |
|     |+----------------------------|        |
|     |+ 数据总线-------------------|        |
|     |+----------------------------|        |
|     |                             |        |
|     |+----------------------------|        |
|     |+ 控制总线-------------------|        |
|     |+----------------------------|        |
|     |                             +--------+
+-----+
```

### 地址总线(Address Bus, AB)

CPU 是通过地址总线来制定存储单元的

地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址

一个CPU有 N 根地址线，则可以说这个CPU的地址总线的宽度为N

```
+-------+--------------+-------------+-------------------------------+-------------------------+
| CPU   | 地址总线宽度 | 寻址能力    | 数据总线宽度 | 一次传输数据量 | 读取 1KB 数据要读多少次 |
+-------+--------------+-------------+-------------------------------+-------------------------+
| 8080  | 16bits       | 64KB        | 8            | 1Byte          | 2^10/1 = 1024           |
+-------+--------------+-------------+-------------------------------+-------------------------+
| 8088  | 20bits       | 1MB         | 8            | 1Byte          | 2^10/1 = 1024           |
+-------+--------------+-------------+-------------------------------+-------------------------+
| 8086  | 20bits       | 1MB         | 16           | 2Byte          | 2^10/2 = 512            |
+-------+--------------+-------------+-------------------------------+-------------------------+
| 80286 | 24bits       | 16MB        | 16           | 2Byte          | 2^10/2 = 512            |
+-------+--------------+-------------+-------------------------------+-------------------------+
| 80386 | 32bits       | 2^32=4GByte | 32           | 4Byte          | 2^10/4 = 256            |
+-------+--------------+-------------+-------------------------------+-------------------------+
```

内存地址空间

    从CPU的角度看地址空间分配

        RAM
            主板上的RAM
            扩展槽上的RAM(如显卡)

        ROM
            系统BIOS
            接口卡上的BIOS

    统一编址, 将各类存储器看作一个逻辑存储器

8086 为例:
```
+-----      00000
|
|
|
+-----      9FFFF    10 x 2^16 = 640KB    655350    主存储器
+-----      A0000
|
+-----      BFFFF    2 x 2^16  = 128KB              显存
+-----      C0000
|
+-----      FFFFF    4 x 2^16  = 256KB              各类 ROM 地址空间

                                 1024KB
```

上低位下高位

```
    +---+       +----+
    | 1 |       | 内 |
地  | 1 |       |    |
    | 0 |       |    |
址  | 1 |  -->  |    |      1011
    | 0 |       |    |
总  | 0 |       | 存 |
    | 0 |       |    |
线  | 0 |       |    |
    +---+       +----+
```

数据总线

控制总线


一个 CPU 有 N 根地址总线，则可以说这个 CPU 的地址总线的宽度为 N

这样的 CPU 最多可以寻址 2 的 N 次方个内存单元


### 数据总线

数据总线的宽度决定了 CPU 和外接的数据传送速度

数据总线DB用于传送数据信息。

数据总线是双向三态形式的总线，
    1. 即他既可以把CPU的数据传送到存储器或I／O接口等其它部件，
    2. 也可以将其它部件的数据传送到CPU。

8088CPU的数据总线宽度为8

8086CPU的数据总线宽度为16


### 控制总线

控制总线是一些不同控制线的集合

有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制, 要么读，要么写，一根就够了

所以，控制总线的宽度

### CPU 对外围设备的控制

CPU 对外部设备都不能直接控制，直接控制这些设备进行工作的是插在扩展插槽上的接口卡。

扩展插槽通过总线和CPU相连，所以扩展卡也通过总线和CPU相连.

**CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制**

### 各类存储器

读写属性上分
    随机存储器RAM 只读存储器ROM

从功能和连接上
    随机存储器 RAM
    装有BIOS的 ROM
    接口卡上的 RAM

不光主板，显卡，网卡上都有 BIOS

各种存储器在逻辑上组成一个逻辑存储器，CPU 将其作为一个整体来看待


RAM
    主板上的RAM
    扩展插槽上的RAM(例如显卡)

ROM
    系统BIOS
    接口卡上的BIOS


## 寄存器

在16进制表示的数据后面加 H
在2进制表示的数据后面加 B
在10进制表示的数据后面什么也不加

[link](http://www.elecfans.com/baike/zhujipeijian/cpu/20180416662703_a.html)

一个典型的 CPU 由运算器、控制器、寄存器等器件组成，这些器件通过内部总线相连

内部总线:实现 CPU 内部各个器件之间的联系

外部总线:实现 CPU 和主板上其他器件之间的联系

8086 CPU 有14个寄存器,他们的名称为:

```
    AX, BX, CX, DX      // 这4个是通用寄存器，用来存放一般性数据(AH AL; BH BL; CH CHL; DH DL, 为了兼容上一代8位)
    SI, DI              // 变址寄存器
    SP, BP              // 指针寄存器
    IP                  // 指令指针寄存器
    DS, ES, SS, CS      // 段寄存器
    PSW                 // 标志寄存器
```

AX:

高位                                  |                            低位
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
AH                                     AL

最大值: 2^16 -1 (FFFF)
8086 的字长(word size)为 16bit



其中8个是通用寄存器，几乎所有的 CPU 都一样的

DS（data segment）——16位的数据段寄存器；
ES（extra segment）——16位的扩展段寄存器；
SS（stack segment）——16位的堆栈段寄存器；
CS（code segment）——16位的代码段寄存器；

2个地址指针寄存器：BP（base pointer），SP（stack pointer）
2个变址寄存器：SI（source index），DI（desTInaTIon index）

标志寄存器FR（flags register）

16位的指令指针寄存器IP


1. 地址
2. 控制(读/写)
3. 数据

### 通用寄存器

AX, BX, CX, DX      //这4个是通用寄存器，用来存放一般性数据

8086 CPU 的寄存器都是16位的，可以存放两个字节，一个字

8086 的上一代 CPU 8088 是8位的，为保证兼容性，这4个寄存器都可以分为两个**独立的8位寄存器**使用

    AX 可以分为 AH 和 AL
    BX 可以分为 BH 和 BL
    CX 可以分为 CH 和 CL
    DX 可以分为 DH 和 DL

AH 和 AL 都是可以独立使用的8位寄存器

二进制后边加'B'
十六进制后边加'H'
十进制什么也不加


**汇编指令不区分大小写**

几条汇编指令:

mov ax,18   // 将 18 送入 AX; AX=18, 一般默认是十进制
mov ah,68
add ax,8    // 将 ax 和 8 相加，放到 ax; AX = AX + 8
mov ax,bx   // AX = AX + BX


### 物理地址

CPU 访问内存单元时要给出内存单元的地址。

**所有的内存单元构成的存储空间是一个一维的线性空间**

我们将这个唯一的地址称为物理地址


16位结构的 CPU 特征

    1. 运算器一次最多可以处理16位的数据
    1. 寄存器最大宽度是16位
    1. 寄存器和运算器之间的通路是16位的

8086 有20位地址总线，可传送20位地址，寻址能力为1M

8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K



    8086
```
+-----------------------------------------------+
|                                               |
| +---------+                   +-----------+   | 段地址左移16进制一位，即2进制的4位，
| |         |  段地址 16位(CS)  |           |   |
| |   其    |-----------------> |地址加法器 |   |
| |   它    |                   |           |   |
| |   部    |-----------------> |           |   |
| |   件    |  偏移地址16位(IP) +-----------+   |
| |         |                       |物|        |
| |         |                       |理|        |
| |         |                       |地| 20位   |
| |         |                       |址|        |
| |         |                       |  |        |
| |         |                   +-----------+   |               +-----------+
| |         |                   |           |   | 20位地址总线  |           |
| |         |                   |           |-------------------|           |
| |         |                   | 输入输出  |   |               |           |
| |         |                   | 控制电路  |   | 数据总线      |  内  存   |
| |         |                   |           |-------------------|           |
| |         |                   |           |   |               |           |
| |         |                   |           |   | 控制总线      |           |
| |         |                   |           |-------------------|           |
| +---------+                   +-----------+   |               +-----------+
+-----------------------------------------------+
```



地址加法器合成物理地址的方法：

    物理地址 = 段地址 X 16 + 偏移地址

    1230 * F -> 12300

    00C8         00C8
    ------------------
                123C8   20位


用分段的方式管理内存
    内存并没有分段,段的划分来自 CPU

段地址x16必然是16的倍数，
偏移地址为16位，16位地址的寻址能力为64KB，所以**一个段的长度最大为64KB**

用不同的段地址和偏移地址形成同一个物理地址

```
    物理地址        段地址          偏移地址
    21F60H          2000H           1F60H           偏移地址 16 位, 变化范围 0-FFFFH, 用偏移地址最多寻址 64KB
                    2100H           0F60H
                    21F0H           0060H
                    21F6H           0000H
                    1F00H           2F60H
```

**CPU 可以用不同的段地址和偏移地址形成同一个物理地址**

表示方法

    在 8086 CPU 中， 存储单元的地址用两个元素来描述，即[段地址]和[偏移地址]

    21F60H 的表述: 数据存在内存 2000:1F60 单元中

### 段寄存器

8086 CPU 有4个段寄存器:
    - CS : code segment   代码段寄存器
    - DS : data           数据段寄存器
    - SS : 栈段寄存器
    - ES : 附加段寄存器

CS 和 IP 是 8086 CPU 中最关键的寄存器，他们指示了 CPU 当前要读取指令的地址

IP 指令指针寄存器

#### 修改 CS IP 的值

1. 使用 r 更改，但这是调试手段

2. mov cs, 2000

    但这是不可行的

    mov ax,2000     这个倒是可以的, 但是ip不可以
    mov cs,ax       这样可以行的通,但是一般不这么用
    mov ip,ax       **不可以,error**

3. 专门使用 jmp 来修改 CS 和 IP 的值

    **要在汇编代码中执行，不能在debug中直接敲**, 而是 a 命令

    jmp 段地址:偏移地址

        jmp 2AE3:3
        jmp 3:0b16


    **仅修改IP的内容，仅仅修改 IP 的值**

        mov ax,200
        jmp ax          (类似于 mov ip,ax)

```

地址    内存机器码  对应汇编指令

        +------+                                +------+
1000 0H |  DB  |                       2000  0H |  B8  |
        |  23  |  mov ax,0123H                  |  22  | mov ax, 6622H
        |  01  |                                |  66  |
        +------+                                +------+
1000 3H |  B8  |                       2000 3H  |  EA  |
        |  00  |  mov ax,0                      |  03  | jmp 1000:3
        |  00  |                                |  00  |
        +------+                                |  00  |
1000 6H |  8B  |  mov bx,ax                     |  00  |
        |  D8  |                                |  10  |
        +------+                                +------+
1000 8H |  FF  |  jmp bx               2000 8H  |  89  | mov cx,ax
        |  E3  |                                |  C1  |
        +------+                                +------+
        |      |                                |      |
        |      |                                |      |


从 2000:0H 开始,执行的序列是:

mov ax, 6622
jmp 1000:3
mov ax, 123
mov ax,0
mov bx, ax
jmp bx

mov ax, 0123h  ---<-----+
mov ax,0                |
mov bx,ax      --->-----+
```



### debug 的使用

实模式

1. R 查看、改变CPU寄存器的内容
    r ax        // 改变 ax 的值
    rax         // 可以没有空格, 默认16进制

2. D 列出预设地址**内存**处的128个字节的内容

    64K->64000B/128 => 500
    2^16/2^7 => 2^9 => 512

    1. d 段地址:偏移地址

        一行 16 个字节, 共计 8 行

    2. d 段地址:偏移地址 结尾偏移地址

        2000:0 f  -> 启示和结尾，共16个   [0,f]


    持续敲击 d 键,则顺序打印 128 字节, 中间不能敲回车

    ```
    073F:0580  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00    ...........    // ascii
    073F:0590  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00    ...........
    073F:05A0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00    ...........
    ...
    073F:05F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00    ...........
    ```

3. E 改变**内存**的值

    e 段地址:便宜地址 数据1 数据2 ...

    e 2000:0 5 41   (A 65: 41H= 4x16+1 )
    e 2000:0 6 41   (a 97: 61H= 6x16+1 )

4. U 把内存中的机器指令翻译成汇编指令

    mov ax, 0123H
    mov bx, 0003H
    mov ax, bx
    add ax,bx

    对应的机器码是:

    B8 23 01
    BB 03 00
    89 D8
    01 D8

    e 2000:0

    u 2000:0
    u 2000:0 f    // 查看 f 个字节

5. A 写入汇编指令

    r 查看 CS:IP
    a 073f:0104
    mov ax,0123     // 16进制
    mov bx,0003
    mov ax,bx
    add ax,bx


6. T 执行及其指令

    执行 CS:IP 处的指令
    rip

[link](https://www.bilibili.com/video/BV1pi4y1P76P?p=13&spm_id_from=pageDriver)

```
+-----------------------------------------------+
|                                               |
| +---------+                   +-----------+   | 段地址左移16进制一位，即2进制的4位，
| |         |  段地址 16位(CS)  |           |   |
| |   其    |-----------------> |地址加法器 |   |
| |   它    |                   |           |   |
| |   部    |-----------------> |           |   |
| |   件    |  偏移地址16位(IP) +-----------+   |
| | AX      |                       |物|        |
| | BX      |                       |理|        |
| |         |                       |地| 20位   |
| |         |                       |址|        |
| |         |                      \|/\|/       |
| |         |  +----------+     +---+--+----+   |               +-----------+
| |         |  |指令缓冲区|-<---|           |   | 20位地址总线  |           |
| |         |  +----------+     |           |-------------------|           |
| |         |       |           | 输入输出  |   |               |           |
| |         |      \|/          | 控制电路  |   | 数据总线      |  内  存   |
| |         |  +----------+     |           |-<<<---------------|           |
| |         |  |执行控制器|     |           |   |               |           |
| |         |  +----------+     |           |   | 控制总线      |           |
| |         |                   |           |-------------------|           |
| +---------+                   +-----------+   |               +-----------+
+-----------------------------------------------+
```

工作过程的简要描述

1. 从CS:IP 指向的内存单元读取执行，读取的指令进入指令缓冲区

2. IP=IP+所读取指令的长度，从而指向下一条指令

3. 执行指令，转到步骤1，重复这个过程

r 查看

r ax 改变 ax 的值


## 第三章

16位的字在内存中的存储

0 地址单元中存放的字节型数据
0 地址单元中存放的字型数据


DS 和 [address]
    数据的段地址
    [偏移地址]

    mov bx,1000H
    mov ds,bx
    mov al,[0]

    不能直接  mov ds,1000H, 8086的硬件电路没有这样设计

    mov bx,1000H
    mov ds,bx
    mov ax,[0]      // 1000:0处的字型数据
    mov [0],cx      // cx中的16位数据送到 1000:0处


    内存                指令
    10000H  > 23        mov ax,1000
    10001H  > 11        mov ds,ax
    10002H  > 22        mov ax,[0]      // 1122
    10003H  > 66        mov bx,[2]      // 6622
                        mov cx,[1]      // 2211
                        add bx,[1]      // 6622+2211
                        add cx,[2]      // 2211+6622

    e 1000:0

    a 2000:0
    汇编代码

    rcs
    rip

    t


    累加数据段中前3个单元中的数据

    mov ax,123B
    mov ds,ax,
    mov al,0
    add al,[0]
    add al,[1]
    add al,[2]

[link](https://www.bilibili.com/video/BV1pi4y1P76P?p=17&spm_id_from=pageDriver)

mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段内存单元, 寄存器
mov 寄存器,段内存单元
mov 内存单元,段寄存器




### 栈结构

栈内存

只能在一端进行插入和删除操作的数据结构

push ax     // 将 ax 中的数据送入栈中, push 谁推进去
pop ax      // 从栈顶取出数据送入 ax, pop 给谁

都是以**"字"**为单位对栈进行操作的


8086 中有两个和栈相关的寄存器

    SS: 栈段寄存器, 存放栈顶的段地址

    SP: 栈顶指针寄存器, 存放栈顶的偏移地址


```
|           +-----------+
| 10000H    |           |
|           +-----------+
|           |           |
|           +-----------+
|           |           |
|           +-----------+
| 10009H    |           |
|           +-----------+
| 1000AH    |           |
|           +-----------+
| 1000BH    |           |
|           +-----------+
| 1000CH    |           |       <-SP3
|           +-----------+
| 1000DH    |           |
|           +-----------+
| 1000EH    |           |       <-SP2
|           +-----------+
| 1000FH    |           |
|           +-----------+
|                               <-SP1
```

SS 栈段寄存器(Stack Segment, 堆栈)
SP 毡顶指针寄存器
    SP = SP - 2


交换数字
    mov ax,001A
    mov bx,001B
    push ax
    push bx
    pop ax
    pop bx



### 总结段: 内存

物理地址 = 段地址 x 16 + 偏移地址(最大64K)

数据段(DS)
    mov, add, sub

代码段(CS)
    CS:IP

堆栈段(SS)
    SS:SP


## 汇编源代码

    源程序文件.asm -> 经过编译成为 目标文件.obj(.lst 是中间结果,crf是交叉引用文件)  -> 经过连接成为 可执行文件.exe
                        masm 源文件                                                      link 文件名
                        交互式的
        masm 源文件;        // 添加分号后不再提示，使用默认的,不用些后缀
        link 文件名;        // 或者 link .obj

    执行的时候不要像 linux 那样写 "./", 直接些 exe 的名字


    masm edit 编辑器工具

    ```
    assume cs:codesg        //伪指令, 这里是将 cs 和 codesg 这个段相关联

    codesg segment          //伪指令

        汇编代码

        mov ax,4c00h        // 这两行是固定格式，程序结束后将CPU的控制权交还给使得它运行的程序(常为DOS系统)
        int 21h

    codesg ends             //伪指令

    end                     //伪指令, 汇编程序结束标记
    ```

**伪指令**: 伪指令没有对应的机器码指令，是由编译器来执行的指令，编译器根据伪指
令来进行相关的编译工作. 就好像C语言中的条件编译


汇编程序: 包含汇编指令和伪指令的文本

1. 一个汇编程序是由多个段组成的，这些段被用来存放**代码, 数据, 堆栈空间**来使用

2. 一个有意义的汇编程序中至少要有一个段，这个段用来存放代码

3. 定义程序中的段:
    
    段名 segment        // 段的开始

    段名 ends           // 段的结束



编译 -> 连接 -> 机器码(.exe)


### 1. 使用 debug 跟踪程序的执行

debug a.exe
r
u

```
|                   +-------+
|       075A:0000   |       |   ----+
|                   +-------+       |
|       075A:0001   |       |       |
|                   +-------+       |
|                   |       |       |
|                   +-------+       |
|                   |       |      256Bytes
|                   +-------+       |
|                   |       |       |
|                   +-------+       |
|       075A:00FF   |       |   ----+
|                   +-------+
|       076A:0000   |       |(075A:0100)
|                   +-------+
|       076A:0000   |       |
|                   +-------+
|                   |       |
|                   +-------+
|                   |       |
|                   +-------+
```





1. 程序加载后，DS 中存放这程序所在内存区的段地址，这个内存区的偏移地址是0，则程序所在的内存区的地址为: DS:0

2. 这个内存区的前256Bytes存PSP(程序段前缀), DOS 用来和程序进行通信

3. 从256Bytes向后的空间存放的是程序，CS值为 DS + 10H

4. 程序加载后，CX 中存放代码的长度(Bytes)

P(Proceed,继续命令): 类似T命令，逐条执行指令，显示结果；但遇到子程序，中断等时，直接执行，然后显示结果

G(Go,运行命令): 从指定地址处开始运行程序，直到遇到断点或者程序正常结束.
    g [cs:ip]

(): 表示一个**内存单元的内容**或**寄存器中的内容**

    ```
    ax中的内容是0010H           -> (ax)=0010H
    2000:1000处的内容是0010H    -> (2100H)=0010H
    mov ax,[2]                  -> (ax)=((ds)*16 + 2)
    mov [2],ax                  -> ((ds)*16 + 2)=(ax)

    push ax                     -> (sp)=(sp)-2
                                   ((ss)*16,+(sp))=(ax)
    ```

loop s      // s 就是偏移地址



### loop

在汇编源程序中，数据不能以字母开头，要在 ffff 前加0

计算 ffff：0006 **字节单元**中的数乘以3， 结果存储在**dx**中
```
assume cs:code
code segment

    mov ax,0ffffh
    mov ds,ax
    mov bx,6
    mov al,[bx]
    mov ah,0

    mov dx,0
    mov cx,3
s:  add dx,ax
    loop s

    mov ax 4c00h
    int 21h
code ends
end
```


### 段前缀

由来
    > mov al,[0]      // 竟然翻译成了   mov al,0

    > mov al,[bx]     // 这个没有问题

在 [idata] 前显示地写上段寄存器
    
    > mov al,ds:[0]

ds:
cs:
ss:
es:



计算 [1000:0,1000,b] 单元中的数据的和，结果保存存在 dx 中

```
assume cs:code
code segment

mov ax,1000h
mov ds,ax
mov bx,0

mov dx,0
mov cx,12

s:      mov al,ds:[bx]
mov ah,0
add dx,ax
inc bx
loop s

mov ax,4c00h
int 21h
code ends
end

```


将内存 1000:0,1000:b 中的数据拷贝到 2000:0,2000:b 单元中

[link](https://www.bilibili.com/video/BV1pi4y1P76P?p=27&spm_id_from=pageDriver)

使用 es 扩展段


### 在代码段中使用数据

在程序的段中存放数据，运行时由操作系统分配空间


编程计算以下8个数据的和，结果存在 ax 寄存器中

    0123H 0456H 0789H 0abcH 0defH 0fedH 0cbaH 0987H


    ```
    assume cs:code
    code segment

        dw 0123h, 0456h, ...        // 在代码段中定义数据; define word; db(define byte); dd(define double word)
         //cs:0   cs:2, 前16字节代表数据，之后才是代码

        mov bx,0                    // 这里也不应该是零，要从 CS:0010开始
        mov ax,0
        mov cx,8

    s:  add ax,cs:[bx]
        add bx,2
        loop s


        mov ax,4c00h
        int 21h
    code ends
    end

    ```

    改进

    ```
    assume cs:code
    code segment
            dw 0123h, 0456h, ...        // 在代码段中定义数据; define word; db(define byte); dd(define double word)
             //cs:0   cs:2, 前16字节代表数据，之后才是代码

    start   mov bx,0                    // 定义一个标号，指示代码开始的位置, 也可以是别的名字, 程序入口点
            mov ax,0
            mov cx,8

    s:      add ax,cs:[bx]
            add bx,2
            loop s


            mov ax,4c00h
            int 21h
    code ends
    end start                           // 结束代码的位置

    ```

### 在代码段中使用栈

在代码段中使用栈，以数据逆序存放

    ```
    assume cs:code
    code segment

    dw 0001h,0002h,0003h,0004h,0005h,6h,7h,8h
    dw 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0

    begin
    mov ax,cs
    mov ss,ax
    mov sp,30h

    mov bx,0
    mov cx,8
    s:      push cs:[bx]
    add bx,2
    loop s

    mov bx,0
    mov cx,8
    p:  pop pop cs:[bx]
    add bx,2
    loop p

    code ends
    end begin

    ```

### 将数据,代码,栈放入不同段

    ```
    assume cs:code, ds:data, ss:stack

    data segment
        dw 0123h,0234h,...
    data ends

    stack segment
        dw 0,0,...
    stack ends

    code segment
    start:
        初始化各段寄存器
        入栈
        出栈
        mov ax,4c00h
        int 21h
    code ends

    end start



    初始化各段寄存器
    mov ax,stack
    mov ss,ax
    mov sp,20h
    mov ax,data
    mov ds,ax


    入栈
        mov  bx,0
        mov cx,8
    s:  push [bx]
        add bx,2
        loop s

    
    出栈
        mov bx,0
        mov cx,8
    s0: pop [bx]
        add bx,2
        loop s0
    ```

## 内存寻址

### 1. 处理字符问题

用单引号表示数据是以字符形式给出的, 编译器将他们转化为相对应的 ASCII 码

data segment
    db 'unIX'       // define byte
    db 'foRK'
data ends

大小写 16进制差 20H

A 0100 0001     a 0110 0001
B 0100 0010     b 0110 0010
C 0100 0011     c 0110 0011
D 0100 0100     d 0110 0100
...

    5 -> 2^5=32 -> 97-65


    ```
    assume cs:codesg, ds:datasg
    datasg segment
        db 'BaSiC'
        db 'iNfOrMaTiOn'
    ends datasg

    codesg segment
    start:
        mov ax,datasg               //
        mov ds,ax

        //小写转大写
        mov bx,0
        mov cx,5
    s:  mov al,[bx]
        and al,11011111b
        mov [bx],al
        inc bx
        loop s

    codesg ends
    end start
    ```


[link](https://www.bilibili.com/video/BV1pi4y1P76P?p=33&spm_id_from=pageDriver)


### 2. 寻址方式

[idata]         直接寻址

[bx]            寄存器间接寻址

[bx+idata]      寄存器相对寻址

[bx+si]         基址变址寻址

[bx+si+idata]   相对基址变址寻址



哪些寄存器用于寻址

bx: 默认 ds 段
si
di
bp: 默认 ss 段

只有这几个可以用在 [] 中

mov ax,[cx]     //错误
mov ax,[ax]     //错误
mov ax,[dx]     //错误
mov ax,[ds]     //错误


在没有寄存器参与的内存单元访问指令中，用 word ptr 或 byte ptr 显性地知名所要访问的内存单元的长度是很必要的，否则


### div 指令


被除数：默认放在AX或者  DX和AX中

除数： 8位或者16位，

+---------+-------------------+-------------------------------------+
| 被除数  |    AX             |   DX和AX(AX放低位，DX放高位)        |
+---------+-------------------+-------------------------------------+
| 除数    |   8位内存或寄存器 |   16位内存或寄存器                  |
+---------+-------------------+-------------------------------------+
| 商      |   AL              |   AX                                |
+---------+-------------------+-------------------------------------+
| 余数    |   AH              |   DX                                |
+---------+-------------------+-------------------------------------+

div 寄存器
div 内存单元

+-----------------------+-----------------------+------------------------------------------+
| 示例指令              | 被除数                | 除数             | 商        | 余数      |
+-----------------------+-----------------------+------------------------------------------+
| div bl                | (ax)                  | (bl)             | (al)      | (ah)      |
+-----------------------+-----------------------+------------------------------------------+
| div byte ptr ds:[0]   | (ax)                  | ((ds)x16+0)      | (al)      | (ah)      |
+-----------------------+-----------------------+------------------------------------------+
| div byte ptr [bx+si+8]| (ax)                  | ((ds)x16+(si)+8) | (al)      | (ah)      |
+-----------------------+-----------------------+------------------------------------------+
| div bx                | ((dx)x10000H+(ax))    | (bx)             | (ax)      | (dx)      |
+-----------------------+-----------------------+------------------------------------------+
| div word ptr es:[0]   | ((dx)x10000H+(ax))    | ((ds)x16+0)      | (ax)      | (dx)      |
+-----------------------+-----------------------+------------------------------------------+
| div word ptr [bx+si+8]| ((dx)x10000H+(ax))    | ((dx)x16+(si)+8) | (ax)      | (dx)      |
+-----------------------+-----------------------+------------------------------------------+




### 英文

    1. AH&AL=AX（accumulator）累加寄存器
    2. BH&BL=BX（base）基址寄存器
    3. CH&CL=CX（count）计数寄存器
    4. DH&DL=DX（data）数据寄存器

    5. CS（Code Segment）代码段寄存器
    6. IP（Instruction Pointer）指令指针寄存器

    7. SS（Stack Segment）堆栈段寄存器
    8. SP（Stack Pointer）堆栈指针寄存器

    BP（Base Pointer）基址指针寄存器

    SI（Source Pointer）源变址寄存器

    DI（Destination Index）目的变址寄存器

    DS（Data Segment）数据段寄存器

    ES（Extra Segment）附加段寄存器


## 汇编语言集成开发环境

windows 环境支持8086实模式工作环境

    MS-DOS方式
    DOSBox
    emu8086
        8086CPU模拟器



Windows 下的汇编工具

    masm32
    visual studio系列


## 反汇编

debug

windbg(微软开发的)


## 混合编程

    ```
    //c语言

    __asm
    {

    }

    //c语言
    ```


## 文件结构分析

Binary Viewer
