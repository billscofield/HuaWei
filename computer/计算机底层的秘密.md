# 计算机底层的秘密笔记

## 1. 从编程语言到可执行程序,这是怎么一回事

### 1.1

#### 1.1.1 

打孔纸来控制计算机

谁来支配谁，谁站主导地位

#### 1.1.2

CPU 执行的指令来来回回就那么几个，如加法指令，跳转指令等

把机器指令映射到人类能看懂的单词

#### 1.1.3 底层的细节 VS 高层的抽象

#### 1.1.5 盗梦空间与递归: 代码的本质

你给这几句表达起了一个高端的名字, 语法

#### 1.1.6 让计算机理解递归

植物学课本

树干可以生树枝，树枝还可以生树枝。一层套一层，梦中之梦，子子孙孙无穷匮。这也是递归

语法树

#### 1.1.7 优秀的翻译官: 编译器

叶子节点的表达是非常简单的, 可以简单地翻译成对应的机器指令，只要把叶子节点翻译
成机器指令，就可以把此结果应用到叶子节点的父节点，父节点又可以把翻译结果应用到
父节点的父节点，一层层向上传递，最终整棵树都可以翻译成具体的机器指令。

完成这个工作的程序有个名字，叫做编译器(Compiler)

#### 1.1.8 解释型语言的诞生

各种各样的硬件CPU

我们可以用程序来仿真CPU执行机器指令的过程，自己定义一套标准指令，只要各类CPU都
有相应的仿真程序，我们的代码就可以直接在不同的平台上运行了，这就是"一次编写，到
处执行"

这个CPU仿真程序叫做"虚拟机", 虚拟机还有一个外号叫"解释器"

```
            +------------+
            | if(xxx)xxx |
            +------------+
                  |
                 \|/
            +------------+
            |  标准指令  |
            +------------+
                  |
                  | 
    +-------------+-----------+
    |             |           |
+--------+   +--------+   +--------+
| 解释器 |   | 解释器 |   | 解释器 |
+--------+   +--------+   +--------+
    |             |           |
+--------+   +--------+   +--------+
|鸟型CPU |   |犬型CPU |   |牛型CPU |
+--------+   +--------+   +--------+
```

编译器根据语言的语法将代码解析成语法树，遍历语法树先生成机器指令(C/C++)或者字节码
(java), 然后交给CPU(或虚拟机)来执行

### 1.2 编译器是如何工作的

#### 1.2.1 编译器就是一个普通程序，没什么大不了的

编译器就是一个将高级语言翻译成低级语言的程序

往大了说是一个翻译器，往小了说就是一个文本处理程序

#### 1.2.2 提取出每一个符号

包含相应符号信息的东西有一个专属名词:符号(token)

编译器的第一项工作就是遍历一边源代码，把所有的 token 都找出来

```
int a = 1;
int b = 2;
while (a < b){
    b = b - 1;
}

---

T_Keyword           int
T_Identifier        a
T_Assign            =
T_Int               1
T_Semicolon         ;

T_Keyword           int
T_Identifier        b
T_Assign            =
T_Int               2
T_Semicolon         ;

T_While             while
T_LeftParen         (
T_Identifier        a
T_Less              <
T_Identifier        b
T_RightParen        )
T_OpenBrace         { 
T_Identifier        b
T_Assign            =
T_Identifier        b
T_Minux             -
T_Int               1
T_Semicolon         ;
T_CloseBrace        }
```

每一行都是一个 token, 左边以 T 开头的一列表示 token 的含义, 右边一列是其值。

从源代码中提取 token 的过程就是**词法分析(Lexical Analysis)**

#### 1.2.3 token 想表达什么含义

编译器会根据语法一丝不苟地工作，哪怕差一个字符都不行， 这个过程叫做**解析(parsing)**

扫描 token 后根据语法生成的树就是语法树

#### 1.2.4 语法树是不是合理的

语义分析

#### 1.2.5 根据语法树生成中间代码

语义分析之后，编译器遍历语法树并用中间代码(Intermediate Representation code, IR code)表示

```
    a = 1
    b = 2
    goto B
A: b = b - 1
B: if a < b goto A
```

#### 1.2.6 代码生成

编译器将上述中间代码转换为汇编指令

编译器将上述汇编指令转换为机器指令

合并目标文件的工作有一个很形象的名字: 链接, 负责链接的程序被称为链接器(Linker)

### 1.3 联接器不能说的秘密

#### 1.3.1 链接器是如何工作的

链接器的任务之一就是要确保这种依赖是成立的，即被依赖的模块中必须有该接口的实现

就是被引用的内容必须存在，这样一本书才是完整的，这个过程被称为**符号决议(Symbol
Resolution)** , 意思是**我们引用的外部符号必须能在其他模块中找到唯一对应的实现**

重定位: 假设某个源代码引用了其他模块定义的 print() 函数，那么编译器在编译该源文
件时根本不知道该函数到底会被放到哪个内存地址上，这是编译器也仅仅用 "N" 来代替，
当链接器汇总合并生成可执行文件时就能知道该函数的确切地址了，这时再把 N 替换成真
正的内存地址

符号决议， 生成可执行文件与重定位


#### 1.3.2 符号决议: 供给与需求

符号指的是 全局变量名 和 函数(因为局部变量是模块私有的，不可以被外部模块引用，
因此链接器并不关心局部变量)

确保所有目标文件引用的外部符号都有定义，该定义必须是唯一的

**该文件有几个符号可以供其他模块使用，该文件引用了几个其他模块定义的符号**

目标文件

    +--------+
    | 代码区 |
    +--------+
    | 数据区 |
    +--------+

编译器把一个源文件可以对外提供哪些符号，以及该文件引用了哪些外部符号都记录了下
来，并将该信息存放在了一张表中，涨涨表就叫**符号表**

目标文件

    +--------+
    | 代码区 |
    +--------+
    | 数据区 |
    +--------+
    | 符号表 |
    +--------+

链接器必须确定供给满足需求

符号决议就是要确保每个目标文件的外部符号都能在符号表中中找到唯一的定义

在实际编写代码时，供给可以超过需求

静态库,在windows 下以 .lib 为后缀, 在 linux 下以 .a 为后缀

#### 1.3.2
#### 1.3.2
#### 1.3.2
#### 1.3.2

## 2. 

