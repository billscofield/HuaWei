
## 模块
1. I/O模型
    1. 网络IO
        1. 本质时socket读取
    1. 磁盘IO

    1. 每次IO，都要经由两个阶段
        1. 将数据从磁盘文件 先加载至**内核内存空间（缓冲区）**，等待数据准备完成，时间较长
        1. 将数据从内核缓冲区复制到**用户空间的进程的内存中**，时间较短

    1. 同步/异步：关注的是消息通信机制
        1. 同步synchronous,调用者等待被调用者返回消息，才能继续执行(调用者主动询问被调用者)
        1. 异步asynchronous,被调用者 主动通知 调用者 被调用者的运行状态

    1. 阻塞/非阻塞:关注调用者在等待结果返回之前所处的状态
        1. 阻塞:block, 指**(内核?)IO操作需要彻底完成后才返回到用户空间**，调用结果返回之前，**调用者被挂起**
        1. 非阻塞:指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成，最终的调用结果返回之前，**调用者不会被挂起**

    1. 同步阻塞IO模型
        1. 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞
        1. 用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作
        1. 用户需要等待read将数据读取到buffer后，才继续处理接受的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够
    1. 同步非阻塞IO模型
        1. 用户线程发起IO请求时立即返回（不挂起）。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即“轮询”机制
        1. 整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回（不挂起），但是为了等到数据，仍需要不断的路轮询、重复请求，消耗了大量的CPU资源
        1. 是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性
    1. IO多路复用模型
        1. 

## 对比阻塞与非阻塞
    1. 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。

    1. 非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的 CPU 核心利用率永远是 100%，I/O 以事件的方式通知。

    1. 在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让 CPU 资源不被阻塞中的线程浪费。

    1. 而在非阻塞模式下，线程不会被 I/O 阻塞，永远在利用 CPU。多线程带来的好处仅仅是在多核 CPU 的情况下利用更多的核。

我们常常提起的异步I/O，其实质是**用户空间中的程序**不用依赖**内核空间中的I/O操作实际完成**，即可进行后续任务。


I/O的同步与异步I/O的同步与异步出现在应用程序中。
    如果做阻塞I/O调用，应用程序等待调用的完成的过程就是一种同步状况。相反，I/O为非阻塞模式时，应用程序则是异步的。
    所以 “同步阻塞”  和  “异步非阻塞”





---

## 一个小故事

故事：小A烧开水。
出场人物：  小A
出场道具：  普通水壶（放在煤气灶上的那种，为了方便简称：水壶）；
            会响的水壶（水烧开了会响的那种，简称：响壶）。
            故事目的：小A要拿开水泡咖啡

小A为了实现目的，指定了4个计划：

1. 用水壶烧水，并且站在煤气灶旁边，啥事不干，两眼直勾勾的盯着水壶，等水烧开。烧开后就去泡咖啡。同步阻塞

假设烧水和泡咖啡是在同一个线程中执行。

2. 仍然用水壶煮水，不过此时不再傻傻得站在那里看水开没开，而是去玩局LOL，每当自己死了，就过来看看水开了没有。如果水开了就去泡咖啡。同步非阻塞

假设这里玩LOL，是另一个线程运行的。

3. 动用响壶烧水，仍然站在煤气灶旁边，不过此时不两眼直勾勾的盯着壶了，而是听响，因为响壶水开时会用响声通知小A。异步阻塞

4. 在计划3的基础上，小A不站在煤气灶旁边了，而是去玩局LOL，等听到响壶的声音提醒后，再去跑咖啡。异步非阻塞

有了上边的故事铺垫，我们再来看一看概念

## 同步：

同步这个词在很多场合下都会被使用，如果单从字面意思来看：相同的步骤。但是在编程的领域里讲，字面意思就不那么准确了。

对于编程领域来说， **同步就是发起一个请求，直到请求返回结果之后，才进行下一步操作**。简单来说，同步就是必须一件事一件事的做，等前一件做完了，才能做下一件事。

例子：此种模式很常见，比如我发起一个网络请求查询一个人的身份证，然后根据身份证查看这个人的详细信息。那么我查询详细信息的操作需要等待查询身份证的操作，那么此时查询身份证的操作就是一个同步操作。

## 异步：

异步很明显是与同步相对，二者的区别在于是否需要等待某操作的返回结果。简单来说，我们还是一个网络请求, **如果我们此时不需要依赖这个请求的结果就能进行后续操作，那么此时这个网络请求就是一个异步操作**。

当一个异步操作发出后, **调用者**在没有得到结果之前，可以继续执行后续操作。这就是异步。

同步和异步的区别：

二者的区别还是很明显的：请求发出后，是否需要等待请求结果，才能继续执行其他操作。

## 阻塞

**阻塞的概念往往伴随着线程**。阻塞一般是指：在调用结果返回之前，**当前线程**会被挂起。调用线程只有在得到结果之后才会被唤醒执行后续的操作。

## 非阻塞

那么非阻塞，毫无疑问是阻塞的反向操作。非阻塞式的调用指：在结果没有返回之前，该调用不会阻塞住当前线程。

是不是感觉阻塞/非阻塞和同步/异步有异曲同工的地方？

其实，这两者存在本质的区别，面向的对象是不同的。

阻塞/非阻塞：进程/线程需要操作的数据如果尚未就绪，是否妨碍了当前进程/线程的后续操作。
同步/异步：数据如果尚未就绪，是否需要等待数据结果。

## 并发和并行

二者的区分度非常的高，就在于四个字:**是否同时**

### 并发：当有多个线程在操作时，如果系统只有一个CPU，操作系统只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段快速的切换不同的线程代码运行。

### 并行：当系统有多个CPU时，可以存在 当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。

举个小例子

小A吃饭吃到一半，电话来了，小A一直到吃完了以后才去接。既不支持并发也不支持并行

小A吃饭吃到一半，电话来了，小A停了下来接了电话，接完后继续吃饭。支持并发

小A吃饭吃到一半，电话来了，小A一边打电话一边吃饭。支持并行



##
进程
    1. 程序的一次执行过程
    1. 操作系统的资源是以进程为单位进行分配的,如内存、文件、...
    1. 操作系统通过CPU调度 将CPU的控制权交给给需要的进程


    1. **资源的拥有者**
    1. **CPU的调度单位**

PCB : Process Control Block 进程控制块
    一个PCB描述一个进程
    一个系统的PCB数是有限制的,这个数目限制就是最大并发

    进程描述信息
        PID Process ID
        UID User ID

线程
    分配线程:
        1. 类似于点菜的服务员,接活
        1. 一个分配线程
    工作线程:
        1. 类似于厨师,干活
        1. 有多个

    **共享进程资源**

    没有引入线程，单线程

    **进程的运行实体**



