
# RegExp

<a href="https://www.imooc.com/video/12539">慕课</a>

* 正则表达式在不同的语言中有细微的差别

## 基本语法

### RegExp对象

1. 字面量,所谓字符串面值，就是字面上看起来是什么就是什么

```
var reg = /\bhello\b/g;
"hello world".replace(reg,"HELLO")
```

1. 构造函数

```
var reg= new RegExp('\\bhello\\b",'g')
"hello world".replace(reg,"HELLO")
```

1. 标识符

    1. g global

    1. i ignore case

    1. m multiple lines 多行搜索

    ```
    "@123
    @234
    @456
    " 有换行符
    .replace(/^@\d/g,'X')   只会替换@123
    换行符也是一个普通字符，m 把换行符当做一个新行
    ```

### 原义字符

### 元字符

1. 有特殊含义的非字母字符
1. *    
1. +
1. ?
1. $ 持续匹配到结束
1. ^
1. .
1. | 
1. \
1. ()
1. {}
1. []

1. \t    水平制表符
1. \v    垂直制表符
1. \n    换行符  new line
1. \r    回车符  carriage return
   \r （return）就是return 回到 本行 行首 这就会把这一行以前的输出 覆盖掉
1. \f    换页符
1. \0    空字符 null
1. \cX   Ctrl-X

1. 关于 换行 与 回车

```
LF，即Line Feed，中文意思“换行”；CR，即Carriage Return，中文意思“回车”。但是我们通常把这两个混为一谈。既然设置成2个，则肯定有其存在的道理，查了一下资料，与大家分享。

关于“回车”（carriage return）和“换行”（line feed）这两个概念的来历和区别。
在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。

于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。

这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。

后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。

Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<换行><回车>”，即“\n\r”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

```

### 字符类 []

1. 其中的任意一个

1. 字符类取反

    [^abc]

### 范围类 -

1. [a-z] 闭区间

1. [a-zA-Z] 闭区间

1. 两个之间的 - 表示范围，想要匹配 - ，只需在最后加上即可

    [0-9-]

    '1990-02-21'.replace(/[0-9-],'A')


### 预定义类
1. .     [^\r\n] 除回车、换行之外的所有字符
1. \d    [0-9]
1. \D    [^0-9]
1. \s    [\t\f\n\r\0B]   空白符space
1. \S    [^\t\f\n\r\0B]  非空白符
1. \w    [a-zA-Z_0-9]    单词字符
1. \W    [^a-zA-Z_0-9]   非单词字符
1. \n    a newline

1. 边界
    1. \b    单词边界(boundary)
    1. \B    非单词边界
    1. ^xxx     以xxx开始
    1. xxx$     以xxx结束


### 量词 {}

1. ?      {0,1}
1. +      {1,}
1. *      {0,}
1. {n}    出现 n 次
1. {n,m}  出现 n 次 到 m 次
1. {n,}   至少出现 n 次
1. {0,m}  最多 m 次
    1. {,m}  错误的

### 贪婪(greedy)与懒惰(lazy)

1. 贪婪（默认）：尽可能多的匹配，直到失败

```
a?
a??
a+
a+?
a*
a*?

123456  \d{3,6}
```

1. 懒惰：在量词后面加 ?

```
123456  \d{3,6}?
```

### 分组 () 独立的整体

1. 使量词作用于分组
1. 或    |       可以识别单词，故单词不用加括号 
1. 只有全部

```
Byron | Casper
Byron 或者 Casper

Byr(on | Ca)sper
```

1. 反向引用 "$n"

```
2015-01-12
"2015-01-12".replace(/(\d{4})-(\d{2})-(\d{2})/g,"$2-$3-$1")

```

1. 忽略分组,只需在分组内加上 ?: 就可以，就是不能使用反向引用

```
(?: Byron).(ok)   //?: 后可以有空格，也可没有
```

### 前瞻 后顾

1. 向前检查，是否符合断言

    * 符合：叫正向前瞻      \w(?=\d)

    * 不符合，叫负向前瞻    \w(?!\d)

1. 向后检查，是否符合断言(JS 不支持)


### 测试工具

<a href="www.regexper.com">REGEXPER</a>

<a href="https://www.debuggex.com">debuggex</a>


### 实例

1. <a href="https://ke.qq.com/webcourse/index.html#course_id=280727&term_id=100332465&taid=1979812420012183&vid=n1424t98z2s">排列组合画图法</a>

    化繁为简，把每个小的部分搞出来

    一个分支就是一个组合()

1. 文件后缀

```
/\.(png|gif|jpe?g)$/

```

1. 数值的匹配

```
var reg= /^-?(0|[1-9]\d*)(\.\d+)?([eE][-+]?\d+)?$/

```






